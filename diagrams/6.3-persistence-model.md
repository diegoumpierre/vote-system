# 6.3 Persistence Model

## Database Tables (PostgreSQL)

```mermaid
erDiagram
    elections {
        UUID id PK
        VARCHAR title
        VARCHAR description
        VARCHAR status
        TIMESTAMP start_date
        TIMESTAMP end_date
        TIMESTAMP created_at
        TIMESTAMP updated_at
    }

    candidates {
        UUID id PK
        UUID election_id FK
        VARCHAR name
        VARCHAR party
        VARCHAR photo_url
        TIMESTAMP created_at
    }

    votes {
        UUID id PK
        UUID election_id FK
        UUID candidate_id FK
        VARCHAR user_id
        TIMESTAMP accepted_at
    }

    elections ||--o{ candidates : "has"
    elections ||--o{ votes : "receives"
    candidates ||--o{ votes : "receives"
```

### Constraints

| Table | Constraint | Type | Purpose |
|-------|-----------|------|---------|
| votes | `uq_votes_election_user (election_id, user_id)` | UNIQUE | Exactly-once voting at DB level |
| votes | `idx_votes_election_candidate (election_id, candidate_id)` | INDEX | Fast aggregation for results |
| candidates | `fk_candidates_election (election_id)` | FK | Cascade delete with election |

---

## Redis Cache Structure

| Key Pattern | Type | TTL | Purpose |
|-------------|------|-----|---------|
| `vote:{electionId}:{userId}` | STRING | 48h | Duplicate vote check |
| `results:{electionId}:{candidateId}` | STRING (counter) | None | Live vote count per candidate |
| `election:{electionId}` | HASH | 1h | Cached election metadata |

---

## Main Queries

### Redis — Check Duplicate Vote

```redis
EXISTS vote:{electionId}:{userId}
```
Returns `1` if user already voted.

### Redis — Increment Vote Counter

```redis
INCR results:{electionId}:{candidateId}
```
Atomically increments the candidate counter. Result Service reads these counters for live results.
